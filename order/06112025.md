async : cho phép dùng await bên trong 
await : chờ 1 future hoàn thành rồi mới làm tiếp

hàm bất đồng bộ trong dart sẽ luôn trả về 1 future 
Future<KIỂU_DỮ_LIỆU> 

HÀM BẤT ĐỒNG BỘ LUÔN TRẢ VỀ Future<T> 
Nhưng không nhất thiết phải có async 

2 cách để tạo ra hàm bất đồng bộ
1. Sử dụng async
2. Tự trả về Future không cần async


gọi dữ liệu trả về của hàm Future ( hàm async ) trong Dart/Flutter
1. dùng async/await

ví dụ :
KET_QUA_TRA_VE = await ASYNC_FUNCTION

2. DÙNG then()
asyncFuction().then((result){
	print('Ket qua : $result'); 
}); 

Instance class và Static class

static class : lưu các hàm chung và sử dụng các hàm tiện ích
Trong Dart, không thể viết Static class function() tương tự 1 số ngôn ngữ khác
cách triển khai static lass trong dart duy nhất là thêm từ khóa static vào các hàm 

Hàm static (hàm tĩnh) là hàm thuộc về lớp (class) chứ không thuộc về đối tượng (instance). Bạn có thể gọi hàm đó trực tiếp qua tên lớp mà không cần tạo đối tượng.

# ARROW FUNCTION
ví dụ Arrow function
```void log(String msg) => print("Log: $msg")```

Sử dụng Arrow fuction : cú pháp rút gọn cho hàm chỉ có 1 biểu thức duy nhất trong dart

# function().then( (_))
Lấy kết quả của hàm async trả về, tuy nhiên không dùng kết quả đo
VD: 
Future<String> func() => return Future.value("thanh nam"); 
void main(){ 
    func().then( (_)){ 
        print("Do not use return result");
    }
}
 
# HÀM BÊN TRONG MỘT HÀM
# closure hoặc anonymous function / function literal.
static void startMonitoring(BuildContext context) {
    Connectivity().onConnectivityChanged.listen((_) async {
      final hasInternet = await _checkInternet();

      if (!hasInternet && !_dialogShown) {
        _dialogShown = true;

        // Show dialog
        if (context.mounted) {
          showDialog(     // showDialog trả về 1 Future khi hộp thoại bị đóng
            context: context,
            barrierDismissible: false,
            builder: (ctx) => ErrorNetworkScreen(),
          ).then((_) {
            // Không sử dụng giá trị trả về của Future sau đo 
            _dialogShown = false; // Reset sau khi dialog đóng
          });
        }
      }
    });
  }

  static Future<bool> _checkInternet() async {
    try {
      final result = await InternetAddress.lookup('google.com'); 
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } on SocketException {
      return false;
    }
  }
}




# Hàm listen((_) async { ... }) 
nhận một callback function (hàm không tên) khi trạng thái mạng thay 
(event) async { 
    // logic xử lí
}


# Ví dụ anonymous function 
class fucn0(){
    static void a(){
        void b() => print("b"); 
        void c() => d(); // Có thể gọi được
    }
    static void d(){
        void e() => print("e");
        c() // Không thể gọi c() ở đây, c() chỉ là hàm cục bộ trong a()
    }
}



static void startNetworkMonitor(BuildContext context){
    Connectivity().onConnectivityChanged().listen((_) async { 
        bool _hasInternet = await _checkInternet();

        if ( !hasInternet & !_dialogShow ){ 
            _diaglogShow = true; 
            if ( context.mounted){ // Đảm bảo buildcontext còn hợp lệ
                showDialog(
                    
                ).then((_)
                    _dialogShow = false;
                );

            }
        }



    };); 
    
}
static Future<bool> _checkInternet() async {
    try {
        bool result = await InternetAdress.lookup("google.com);
        return result.isNotEmpty && result[0].rawAdress.isNotEmpty ;
    } on SocketException e{
        return False;
    }

    
}
# result[0].rawAddress.isNotEmpty
Lấy IP đầu tiên (ở vị trí 0).
rawAddress là địa chỉ IP dưới dạng Uint8List, ví dụ: [142, 250, 190, 78] (IPv4).

Nếu rawAddress cũng không rỗng → xác nhận chắc chắn là có IP hợp lệ.


DNS không trả về IP, hoặc bị lỗi trong quá trình phân tích kết quả → rawAddress sẽ là [] (rỗng)